// generated by narray; DO NOT EDIT
// more info at github.com/akualab/narray

package narray

import "math"

// Abs applies math.Abs() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Abs(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Abs(v)
	}
	return out
}

// Acosh applies math.Acosh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Acosh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Acosh(v)
	}
	return out
}

// Asin applies math.Asin() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Asin(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Asin(v)
	}
	return out
}

// Acos applies math.Acos() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Acos(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Acos(v)
	}
	return out
}

// Asinh applies math.Asinh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Asinh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Asinh(v)
	}
	return out
}

// Atan applies math.Atan() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Atan(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Atan(v)
	}
	return out
}

// Atanh applies math.Atanh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Atanh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Atanh(v)
	}
	return out
}

// Cbrt applies math.Cbrt() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cbrt(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Cbrt(v)
	}
	return out
}

// Erf applies math.Erf() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Erf(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Erf(v)
	}
	return out
}

// Erfc applies math.Erfc() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Erfc(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Erfc(v)
	}
	return out
}

// Exp applies math.Exp() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Exp(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Exp(v)
	}
	return out
}

// Exp2 applies math.Exp2() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Exp2(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Exp2(v)
	}
	return out
}

// Expm1 applies math.Expm1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Expm1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Expm1(v)
	}
	return out
}

// Floor applies math.Floor() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Floor(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Floor(v)
	}
	return out
}

// Ceil applies math.Ceil() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Ceil(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Ceil(v)
	}
	return out
}

// Trunc applies math.Trunc() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Trunc(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Trunc(v)
	}
	return out
}

// Gamma applies math.Gamma() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Gamma(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Gamma(v)
	}
	return out
}

// J0 applies math.J0() elementwise to a multidimensional array.
// See math package in standard lib for details.
func J0(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.J0(v)
	}
	return out
}

// Y0 applies math.Y0() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Y0(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Y0(v)
	}
	return out
}

// J1 applies math.J1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func J1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.J1(v)
	}
	return out
}

// Y1 applies math.Y1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Y1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Y1(v)
	}
	return out
}

// Log applies math.Log() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Log(v)
	}
	return out
}

// Log10 applies math.Log10() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log10(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Log10(v)
	}
	return out
}

// Log2 applies math.Log2() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log2(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Log2(v)
	}
	return out
}

// Log1p applies math.Log1p() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log1p(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Log1p(v)
	}
	return out
}

// Logb applies math.Logb() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Logb(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Logb(v)
	}
	return out
}

// Cos applies math.Cos() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cos(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Cos(v)
	}
	return out
}

// Sin applies math.Sin() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sin(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Sin(v)
	}
	return out
}

// Sinh applies math.Sinh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sinh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Sinh(v)
	}
	return out
}

// Cosh applies math.Cosh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cosh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Cosh(v)
	}
	return out
}

// Sqrt applies math.Sqrt() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sqrt(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Sqrt(v)
	}
	return out
}

// Tan applies math.Tan() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Tan(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Tan(v)
	}
	return out
}

// Tanh applies math.Tanh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Tanh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k, v := range in.Data {
		out.Data[k] = math.Tanh(v)
	}
	return out
}
