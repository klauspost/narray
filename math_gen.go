// generated by narray; DO NOT EDIT
// more info at github.com/akualab/narray

package narray

import "math"

// Abs applies math.Abs() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Abs(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Abs(in.Data[k])
	}
	return out
}

// Acosh applies math.Acosh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Acosh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Acosh(in.Data[k])
	}
	return out
}

// Asin applies math.Asin() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Asin(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Asin(in.Data[k])
	}
	return out
}

// Acos applies math.Acos() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Acos(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Acos(in.Data[k])
	}
	return out
}

// Asinh applies math.Asinh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Asinh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Asinh(in.Data[k])
	}
	return out
}

// Atan applies math.Atan() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Atan(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Atan(in.Data[k])
	}
	return out
}

// Atanh applies math.Atanh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Atanh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Atanh(in.Data[k])
	}
	return out
}

// Cbrt applies math.Cbrt() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cbrt(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Cbrt(in.Data[k])
	}
	return out
}

// Erf applies math.Erf() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Erf(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Erf(in.Data[k])
	}
	return out
}

// Erfc applies math.Erfc() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Erfc(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Erfc(in.Data[k])
	}
	return out
}

// Exp applies math.Exp() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Exp(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Exp(in.Data[k])
	}
	return out
}

// Exp2 applies math.Exp2() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Exp2(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Exp2(in.Data[k])
	}
	return out
}

// Expm1 applies math.Expm1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Expm1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Expm1(in.Data[k])
	}
	return out
}

// Floor applies math.Floor() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Floor(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Floor(in.Data[k])
	}
	return out
}

// Ceil applies math.Ceil() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Ceil(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Ceil(in.Data[k])
	}
	return out
}

// Trunc applies math.Trunc() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Trunc(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Trunc(in.Data[k])
	}
	return out
}

// Gamma applies math.Gamma() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Gamma(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Gamma(in.Data[k])
	}
	return out
}

// J0 applies math.J0() elementwise to a multidimensional array.
// See math package in standard lib for details.
func J0(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.J0(in.Data[k])
	}
	return out
}

// Y0 applies math.Y0() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Y0(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Y0(in.Data[k])
	}
	return out
}

// J1 applies math.J1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func J1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.J1(in.Data[k])
	}
	return out
}

// Y1 applies math.Y1() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Y1(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Y1(in.Data[k])
	}
	return out
}

// Log applies math.Log() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Log(in.Data[k])
	}
	return out
}

// Log10 applies math.Log10() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log10(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Log10(in.Data[k])
	}
	return out
}

// Log2 applies math.Log2() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log2(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Log2(in.Data[k])
	}
	return out
}

// Log1p applies math.Log1p() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Log1p(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Log1p(in.Data[k])
	}
	return out
}

// Logb applies math.Logb() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Logb(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Logb(in.Data[k])
	}
	return out
}

// Cos applies math.Cos() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cos(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Cos(in.Data[k])
	}
	return out
}

// Sin applies math.Sin() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sin(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Sin(in.Data[k])
	}
	return out
}

// Sinh applies math.Sinh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sinh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Sinh(in.Data[k])
	}
	return out
}

// Cosh applies math.Cosh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Cosh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Cosh(in.Data[k])
	}
	return out
}

// Sqrt applies math.Sqrt() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Sqrt(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Sqrt(in.Data[k])
	}
	return out
}

// Tan applies math.Tan() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Tan(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Tan(in.Data[k])
	}
	return out
}

// Tanh applies math.Tanh() elementwise to a multidimensional array.
// See math package in standard lib for details.
func Tanh(out, in *NArray) *NArray {
	if out == nil {
		out = New(in.Shape...)
	}
	for k := range in.Data {
		out.Data[k] = math.Tanh(in.Data[k])
	}
	return out
}
