// Copyright (c) 2015 AKUALAB INC., All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Generate math file using "go run genarray.go"
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"text/template"
)

var exclude = map[string]bool{"Sqrt": true, "Abs": true, "Min": true, "Max": true, "Copysign": true}

// Match lines with pattern: "func Log(x float64) float64"
var re1 = regexp.MustCompile("^func ([A-Z][[:alnum:]]*)[(][[:alnum:]]+ float64[)] float64")

// Match lines with pattern: "func Remainder(x, y float64) float64"
var re2 = regexp.MustCompile("^func ([A-Z][[:alnum:]]*)[(][[:alnum:]]+, [[:alnum:]]+ float64[)] float64")

type genType struct {
	Format   string
	Package  string
	Float64  bool
	Float32  bool
	Biggest  string
	Smallest string
}

var generateTypes = []genType{
	genType{Format: "float32", Package: "na32", Float32: true, Biggest: "float32(math.MaxFloat32)", Smallest: "float32(-math.MaxFloat32)"},
	genType{Format: "float64", Package: "na64", Float64: true, Biggest: "math.MaxFloat64", Smallest: "-math.MaxFloat64"},
}

func main() {
	for _, t := range generateTypes {
		fmt.Printf("Generating code for format %s in package %s\n", t.Format, t.Package)
		genMath(t)
		genFiles(t)
	}
}

// Generates math package bindings.
func genMath(t genType) {
	var g Generator
	n1, n2 := names()
	outputName := t.Package + string(os.PathSeparator) + "math_gen.go"
	fmt.Printf("Generating %d narray functions:\n1 param:%s\n2 params:%s\n", len(n1)+len(n2), n1, n2)

	g.Printf("// generated by narray; DO NOT EDIT\n")
	g.Printf("// more info at github.com/akualab/narray\n")
	g.Printf("\n")
	g.Printf("package %s\n\n", t.Package)
	g.Printf("import \"math\"\n\n")

	for _, name := range n1 {

		g.Printf("// %s applies math.%s() elementwise to a multidimensional array.\n", name, name)
		g.Printf("// See math package in standard lib for details.\n//\n")
		g.Printf("// If 'out' is nil a new array is created.\n")
		g.Printf("// Will panic if 'out' and 'in' shapes don't match.\n")
		g.Printf("func %s(out, in *NArray) *NArray {\n", name)
		g.Printf("	if out == nil {\n")
		g.Printf("		out = New(in.Shape...)\n")
		g.Printf("	} else if !EqualShape(out, in) {\n")
		g.Printf("      panic(\"%s:narrays must have equal shape.\")\n", name)
		g.Printf("  }\n")
		g.Printf("	for k,v := range in.Data {\n")
		g.Printf("		out.Data[k] = %s(math.%s(float64(v)))\n", t.Format, name)
		g.Printf("	}\n")
		g.Printf("	return out\n")
		g.Printf("}\n")
		g.Printf("\n")
	}

	for _, name := range n2 {

		g.Printf("// %s applies math.%s() elementwise to two multidimensional arrays.\n", name, name)
		g.Printf("// See math package in standard lib for details.\n//\n")
		g.Printf("// If out is nil a new array is created.\n")
		g.Printf("// Will panic if 'out', 'a' and 'b' shapes don't match.\n")
		g.Printf("func %s(out, a, b *NArray) *NArray {\n", name)
		g.Printf("	if out == nil {\n")
		g.Printf("		out = New(a.Shape...)\n")
		g.Printf("	}\n")
		g.Printf("  if !EqualShape(out, a, b) {\n")
		g.Printf("      panic(\"%s:narrays must have equal shape.\")\n", name)
		g.Printf("  }\n")
		g.Printf("	for k,v := range a.Data {\n")
		g.Printf("		out.Data[k] = %s(math.%s(float64(v), float64(b.Data[k])))\n", t.Format, name)
		g.Printf("	}\n")
		g.Printf("	return out\n")
		g.Printf("}\n")
		g.Printf("\n")
	}

	// Format the output.
	src := g.format()

	// Write to file.
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Get list of function names with 1 or 2 parameters
func names() ([]string, []string) {

	var names []string
	var names2 []string
	for _, path := range goFiles() {

		f, err := os.Open(path)
		if err != nil {
			panic(err)
		}
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			line := scanner.Text()
			name, ok := f2f(line, re1)
			_, ok2 := exclude[name]
			if ok && !ok2 {
				names = append(names, name)
			}
			name, ok = f2f(line, re2)
			_, ok2 = exclude[name]
			if ok && !ok2 {
				names2 = append(names2, name)
			}
		}
		if err := scanner.Err(); err != nil {
			fmt.Fprintf(os.Stderr, "error reading file [%s]: %s", path, err)
		}
		err = f.Close()
		if err != nil {
			panic(err)
		}
	}
	return names, names2
}

// Get list of Go files to analyze.
func goFiles() []string {

	mathDir := filepath.Join(runtime.GOROOT(), "src", "math")
	var files []string
	err := filepath.Walk(mathDir, func(path string, info os.FileInfo, err error) error {

		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		if strings.HasSuffix(path, "_test.go") {
			return nil
		}

		if strings.HasSuffix(path, ".go") {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		panic(err)
	}
	return files
}

// Returns a function name if it has the re pattern.
func f2f(line string, re *regexp.Regexp) (string, bool) {

	result := re.FindStringSubmatch(line)
	if len(result) == 2 {
		return result[1], true
	}
	return "", false
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Write(p []byte) (n int, err error) {
	return g.buf.Write(p)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

// Generate files from Templates
// The arrays must match in order
var outFiles = []string{"gonum.go", "gonum_test.go", "narray.go", "narray_test.go", "arrayfuncs.go"}
var templateFiles = []string{"gonum.go.tpl", "gonum_test.go.tpl", "narray.go.tpl", "narray_test.go.tpl", "arrayfuncs.go.tpl"}

// Generate files from templates
func genFiles(t genType) {
	templ, err := template.ParseFiles(templateFiles...)
	if err != nil {
		panic(err)
	}
	for i, file := range outFiles {
		fmt.Printf("Generating file %s for type %s\n", file, t.Format)

		var g Generator
		g.Printf("// generated by narray; DO NOT EDIT\n\n")
		err = templ.ExecuteTemplate(&g, templateFiles[i], t)
		if err != nil {
			panic(err)
		}
		// Format the output.
		src := g.format()

		// Write to file.
		outputName := t.Package + string(os.PathSeparator) + file
		err = ioutil.WriteFile(outputName, src, 0644)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}
